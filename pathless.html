<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border-width: 3px;
				--border-color: blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				scrollbar-width: none;
				-ms-overflow-style: none;
				user-select: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
			}
			body {
				border: medium solid var(--border-color);
				border-radius: 0.3125em;
			}
			#app {
				height: 100vh;
				position: relative;
			}
			.panel {
				position: absolute;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 2rem;
				padding: 1em;
				overflow: auto;
				background: black;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
		</style>
		<script>
			document.addEventListener(
				'DOMContentLoaded',
				() => new FrameViewer('')
			);

			class FrameViewer {
				constructor(apiUrl = '{{.APIURL}}') {
					this.apiUrl = apiUrl;
					this.app = document.getElementById('app');
					this.panels = Array.from(this.app.children);
					this.state = {
						layout: 1,
						orientation: 'l',
						focus: 0,
						frames: [0, 0, 0],
						totalFrames: null,
					};
					this.cache = new Map();

					document.addEventListener('keydown', (e) =>
						({
							1: () => this.setLayout(1),
							2: () => this.setLayout(2),
							3: () => this.setLayout(3),
							4: () => this.cycleContent(),
							Tab: () => (e.preventDefault(), this.cycleFocus()),
							e: () => this.navigate(1),
							q: () => this.navigate(-1),
						}[e.key]?.())
					);

					this.updateLayout();
					this.render();
				}

				setLayout(layout) {
					if (this.state.layout === layout)
						return this.toggleOrientation();
					if (layout === 1 && this.state.focus)
						[
							this.state.frames[0],
							this.state.frames[this.state.focus],
							this.state.focus,
						] = [
							this.state.frames[this.state.focus],
							this.state.frames[0],
							0,
						];
					this.state.layout = layout;
					if (layout === 2) this.state.orientation = 'h';
					else if (layout === 3) this.state.orientation = 'l';
					this.updateLayout();
					this.render();
				}

				toggleOrientation() {
					const { layout } = this.state;
					if (layout === 2)
						this.state.orientation =
							this.state.orientation === 'h' ? 'v' : 'h';
					else if (layout === 3) {
						const cycle = { l: 't', t: 'r', r: 'b', b: 'l' };
						this.state.orientation = cycle[this.state.orientation];
					}
					if (layout > 1) this.updateLayout();
				}

				cycleFocus() {
					if (this.state.layout > 1)
						this.state.focus =
							(this.state.focus + 1) % this.state.layout;
				}

				cycleContent() {
					const { layout, frames, orientation } = this.state;
					if (layout === 2) {
						[frames[0], frames[1]] = [frames[1], frames[0]];
					} else if (layout === 3) {
						if (orientation === 'l' || orientation === 't') {
							[frames[0], frames[1], frames[2]] = [
								frames[2],
								frames[0],
								frames[1],
							];
						} else {
							[frames[0], frames[1], frames[2]] = [
								frames[1],
								frames[2],
								frames[0],
							];
						}
					}
					if (layout > 1) {
						this.state.focus = (this.state.focus + 1) % layout;
						this.render();
					}
				}

				navigate(delta) {
					const idx = this.state.focus,
						max = this.state.totalFrames || 1000;
					this.state.frames[idx] =
						(((this.state.frames[idx] + delta) % max) + max) % max;
					this.renderPanel(idx);
				}

				updateLayout() {
					const { layout, orientation } = this.state;
					const w = this.app.clientWidth,
						h = this.app.clientHeight,
						b = `${this.constructor.borderWidth}px solid var(--border-color)`;

					const applyPanel = (idx, cfg) => {
						const s = this.panels[idx].style;
						s.display = 'flex';
						s.left = cfg.left + 'px';
						s.top = cfg.top + 'px';
						s.width = cfg.width + 'px';
						s.height = cfg.height + 'px';
						s.border = 'none';
						if (cfg.border) s[`border${cfg.border}`] = b;
					};

					this.panels.forEach((p) => (p.style.display = 'none'));

					if (layout === 1) {
						applyPanel(0, { left: 0, top: 0, width: w, height: h });
					} else if (layout === 2) {
						if (orientation === 'h') {
							applyPanel(0, {
								left: 0,
								top: 0,
								width: w / 2,
								height: h,
								border: 'Right',
							});
							applyPanel(1, {
								left: w / 2,
								top: 0,
								width: w / 2,
								height: h,
							});
						} else {
							applyPanel(0, {
								left: 0,
								top: 0,
								width: w,
								height: h / 2,
								border: 'Bottom',
							});
							applyPanel(1, {
								left: 0,
								top: h / 2,
								width: w,
								height: h / 2,
							});
						}
					} else if (layout === 3) {
						if (orientation === 'l') {
							applyPanel(0, {
								left: 0,
								top: 0,
								width: w / 2,
								height: h,
								border: 'Right',
							});
							applyPanel(1, {
								left: w / 2,
								top: 0,
								width: w / 2,
								height: h / 2,
								border: 'Bottom',
							});
							applyPanel(2, {
								left: w / 2,
								top: h / 2,
								width: w / 2,
								height: h / 2,
							});
						} else if (orientation === 't') {
							applyPanel(0, {
								left: 0,
								top: 0,
								width: w,
								height: h / 2,
								border: 'Bottom',
							});
							applyPanel(1, {
								left: 0,
								top: h / 2,
								width: w / 2,
								height: h / 2,
								border: 'Right',
							});
							applyPanel(2, {
								left: w / 2,
								top: h / 2,
								width: w / 2,
								height: h / 2,
							});
						} else if (orientation === 'r') {
							applyPanel(0, {
								left: w / 2,
								top: 0,
								width: w / 2,
								height: h,
								border: 'Left',
							});
							applyPanel(1, {
								left: 0,
								top: 0,
								width: w / 2,
								height: h / 2,
								border: 'Bottom',
							});
							applyPanel(2, {
								left: 0,
								top: h / 2,
								width: w / 2,
								height: h / 2,
							});
						} else if (orientation === 'b') {
							applyPanel(0, {
								left: 0,
								top: h / 2,
								width: w,
								height: h / 2,
								border: 'Top',
							});
							applyPanel(1, {
								left: 0,
								top: 0,
								width: w / 2,
								height: h / 2,
								border: 'Right',
							});
							applyPanel(2, {
								left: w / 2,
								top: 0,
								width: w / 2,
								height: h / 2,
							});
						}
					}
				}

				static borderWidth = 3;

				async fetchFrame(idx) {
					if (this.cache.has(idx)) return this.cache.get(idx);
					if (!this.apiUrl)
						return this.cache
							.set(idx, `<div>Frame ${idx}</div>`)
							.get(idx);
					try {
						const res = await fetch(this.apiUrl, {
							headers: { 'X-Frame-Request': idx.toString() },
						});
						if (!res.ok) throw new Error(`HTTP ${res.status}`);
						const total = res.headers.get('X-Total-Frames');
						if (total && !this.state.totalFrames)
							this.state.totalFrames = parseInt(total);
						const html = await res.text();
						return this.cache.set(idx, html).get(idx);
					} catch (err) {
						console.error(`Failed to fetch frame ${idx}:`, err);
						return this.cache
							.set(idx, `<div>Error loading frame ${idx}</div>`)
							.get(idx);
					}
				}

				async renderPanel(idx) {
					this.panels[idx].innerHTML = await this.fetchFrame(
						this.state.frames[idx]
					);
				}

				async render() {
					await Promise.all(
						Array.from({ length: this.state.layout }, (_, i) =>
							this.renderPanel(i)
						)
					);
				}
			}
		</script>
	</head>
	<body>
		<div id="app">
			<div class="panel"></div>
			<div class="panel"></div>
			<div class="panel"></div>
		</div>
	</body>
</html>
