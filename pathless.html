<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
				-ms-overflow-style: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
				scroll-behavior: smooth;
			}
			body {
				border: var(--border);
				border-radius: 0.3125em;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.panel {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.panel > * {
				max-width: 100%;
				object-fit: contain;
			}
			/* Single panel */
			.layout-0-0 {
				grid-template: 1fr / 1fr;
			}
			/* Two panels - horizontal */
			.layout-1-0 {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-1-0 #zero {
				border-right: var(--border);
			}
			/* Two panels - vertical */
			.layout-1-1 {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-1-1 #zero {
				border-bottom: var(--border);
			}
			/* Three panels - all variants */
			.layout-2-0,
			.layout-2-1,
			.layout-2-2,
			.layout-2-3 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			/* Variant 0: Left large (zero), right stacked */
			.layout-2-0 #zero {
				grid-row: 1 / 3;
				border-right: var(--border);
			}
			.layout-2-0 #one {
				border-bottom: var(--border);
			}
			/* Variant 1: Top large (zero), bottom split */
			.layout-2-1 #zero {
				grid-column: 1 / 3;
				border-bottom: var(--border);
			}
			.layout-2-1 #one {
				border-right: var(--border);
			}
			/* Variant 2: Right large (zero), left stacked */
			.layout-2-2 #zero {
				grid-row: 1 / 3;
				grid-column: 2;
				border-left: var(--border);
			}
			.layout-2-2 #one {
				border-bottom: var(--border);
			}
			/* Variant 3: Bottom large (zero), top split */
			.layout-2-3 #zero {
				grid-row: 2;
				grid-column: 1 / 3;
				border-top: var(--border);
			}
			.layout-2-3 #one {
				border-right: var(--border);
			}
		</style>
		<script>
			window.apiUrl = '{{.APIURL}}';

			class One {
				constructor() {
					this.fx = new Fx();
					this.zero = new Zero();
					this.state = new Map(
						this.fx.panels.map((panel) => [panel, 0])
					);

					document.addEventListener('keydown', (e) =>
						this.handleKey(e)
					);
					this.renderAll();
				}

				async renderAll() {
					await Promise.all(
						this.fx.getVisible().map((panel) => {
							const frameIndex = this.state.get(panel);
							return this.zero.render(panel, frameIndex);
						})
					);
				}

				async navigate(delta) {
					const total = this.zero.totalFrames || 1;
					const panel = this.fx.getFocusedPanel();
					const currentFrame = this.state.get(panel);
					const newFrame =
						(((currentFrame + delta) % total) + total) % total;

					this.state.set(panel, newFrame);
					await this.zero.render(panel, newFrame);
				}

				handleKey(e) {
					const actions = {
						e: () => this.navigate(1),
						q: () => this.navigate(-1),
						1: () => this.fx.toggleFullscreen(),
						2: () => {
							this.fx.setLayout(1);
							this.renderAll();
						},
						3: () => {
							this.fx.setLayout(2);
							this.renderAll();
						},
						Tab: () => (e.preventDefault(), this.fx.cycleFocus()),
					};

					if (actions[e.key]) actions[e.key]();
					const focusedPanel = this.fx.getFocusedPanel();
					if (focusedPanel) {
						focusedPanel.dispatchEvent(
							new CustomEvent('panelKey', {
								detail: { key: e.key },
							})
						);
					}
				}
			}

			class Fx {
				constructor() {
					this.app = document.getElementById('app');
					this.panels = ['zero', 'one', 'two'].map((id) =>
						document.getElementById(id)
					);
					this.layout = [0, 0];
					this.focus = 0;
					this.fullscreen = false;
					this.savedState = null;
					this.layouts = [
						{ panels: 1, variants: 1 },
						{ panels: 2, variants: 2 },
						{ panels: 3, variants: 4 },
					];
					this.render();
				}

				getVisible() {
					const count = this.layouts[this.layout[0]].panels;
					return this.panels.slice(0, count);
				}

				getFocusedPanel() {
					return this.panels[this.focus];
				}

				getPanelByElement(element) {
					return element.closest('.panel');
				}

				toggleFullscreen() {
					if (this.fullscreen) {
						this.fullscreen = false;
						this.layout = this.savedState.layout;
						this.focus = this.savedState.focus;
						this.savedState = null;
						this.render();
					} else {
						this.savedState = {
							layout: [...this.layout],
							focus: this.focus,
						};
						this.fullscreen = true;
						this.layout = [0, 0];
						this.render();
						this.panels.forEach((panel, i) => {
							panel.style.display =
								i === this.savedState.focus ? 'flex' : 'none';
						});
					}
				}

				setLayout(layoutIndex) {
					if (this.fullscreen) {
						this.toggleFullscreen();
					}
					const currentLayout = this.layouts[layoutIndex];
					const layoutChanged = this.layout[0] !== layoutIndex;
					if (layoutChanged) {
						if (this.focus >= currentLayout.panels) {
							this.focus = 0;
						}
						this.layout = [layoutIndex, 0];
					} else {
						this.layout[1] =
							(this.layout[1] + 1) % currentLayout.variants;
					}
					this.render();
				}

				cycleFocus() {
					if (this.fullscreen) return;
					this.focus = (this.focus + 1) % this.getVisible().length;
				}

				render() {
					const visible = this.getVisible();
					this.app.className = `layout-${this.layout[0]}-${this.layout[1]}`;

					this.panels.forEach((panel, i) => {
						panel.style.display =
							i < visible.length ? 'flex' : 'none';
					});
				}
			}

			class Zero {
				constructor() {
					this.frames = new Map();
					this.totalFrames = null;
					this.pending = new Map();
				}

				async fetchFrame(idx) {
					// Return cached or pending
					if (this.frames.has(idx)) return this.frames.get(idx);
					if (this.pending.has(idx)) return this.pending.get(idx);

					// Ensure frame 0 is fetched first to get totalFrames
					if (this.totalFrames === null && idx !== 0) {
						await this.fetchFrame(0);
					}

					// Create and cache fetch promise
					const fetchPromise = fetch(window.apiUrl, {
						headers: idx === 0 ? {} : { 'X-Frame': String(idx) },
					})
						.then(async (res) => {
							if (!res.ok) throw new Error(`HTTP ${res.status}`);

							// Extract total frames from first response
							if (this.totalFrames === null) {
								const total = res.headers.get('X-Frames');
								if (total)
									this.totalFrames = parseInt(total, 10);
							}

							return res.text();
						})
						.catch((err) => {
							console.error(`Failed to fetch frame ${idx}:`, err);
							return `<div>Error loading frame ${idx}</div>`;
						});

					this.pending.set(idx, fetchPromise);

					try {
						const content = await fetchPromise;
						this.frames.set(idx, content);
						return content;
					} finally {
						this.pending.delete(idx);
					}
				}

				async fetchData(key, url) {
					const dataKey = `__data_${key}`;
					if (this.frames.has(dataKey))
						return this.frames.get(dataKey);
					if (this.pending.has(dataKey))
						return this.pending.get(dataKey);
					const promise = fetch(url)
						.then(async (res) => {
							if (!res.ok) throw new Error(`HTTP ${res.status}`);
							const contentType = res.headers.get('content-type');
							// return blob URL for images, otherwise parse as JSON
							if (contentType?.startsWith('image/')) {
								const blob = await res.blob();
								return URL.createObjectURL(blob);
							}
							return res.json();
						})
						.then((data) => {
							this.frames.set(dataKey, data);
							return data;
						})
						.catch((err) => {
							console.error(`Error fetching data ${key}:`, err);
							throw err;
						});
					this.pending.set(dataKey, promise);
					try {
						return await promise;
					} finally {
						this.pending.delete(dataKey);
					}
				}

				getData(key) {
					return this.frames.get(`__data_${key}`);
				}

				async render(panel, frameIdx) {
					const content = await this.fetchFrame(frameIdx);
					panel.innerHTML = content;
					if (!panel.__frameState) panel.__frameState = {};
					['script', 'style'].forEach((tag) => {
						panel.querySelectorAll(tag).forEach((old) => {
							const el = document.createElement(tag);
							Array.from(old.attributes).forEach((attr) =>
								el.setAttribute(attr.name, attr.value)
							);
							el.textContent = old.textContent;
							old.replaceWith(el);
						});
					});
				}

				getPanelState(panel) {
					return panel.__frameState || {};
				}

				setPanelState(panel, key, value) {
					if (!panel.__frameState) panel.__frameState = {};
					panel.__frameState[key] = value;
				}

				clearPanelState(panel) {
					panel.__frameState = {};
				}
			}

			document.addEventListener('DOMContentLoaded', () => {
				window.app = new One();
				window.frameAPI = {
					getPanel: (scriptElement) =>
						window.app.fx.getPanelByElement(scriptElement),
					getFrameIndex: (panel) => {
						return window.app.state.get(panel) || 0;
					},
					getState: (panel) => window.app.zero.getPanelState(panel),
					setState: (panel, key, value) =>
						window.app.zero.setPanelState(panel, key, value),
					fetchData: (key, url) =>
						window.app.zero.fetchData(key, url),
					getData: (key) => window.app.zero.getData(key),
					onKey: (panel, handler) => {
						panel.addEventListener('panelKey', (e) =>
							handler(e.detail.key)
						);
					},
				};
			});
		</script>
	</head>
	<body>
		<div id="app">
			<div id="zero" class="panel"></div>
			<div id="one" class="panel"></div>
			<div id="two" class="panel"></div>
		</div>
	</body>
</html>
