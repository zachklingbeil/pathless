<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border-width: 3px;
				--border-color: blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				scrollbar-width: none;
				-ms-overflow-style: none;
				user-select: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
			}
			body {
				border: medium solid var(--border-color);
				border-radius: 0.3125em;
			}
			#app {
				height: 100vh;
				position: relative;
			}
			.panel {
				position: absolute;
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow-x: hidden;
			}
			.panel > * {
				max-width: 100%;
				object-fit: contain;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
		</style>
		<script>
			document.addEventListener(
				'DOMContentLoaded',
				() => new FrameViewer('{{.APIURL}}')
			);

			class FrameViewer {
				static ORIENTATIONS = {
					2: { h: 'v', v: 'h' },
					3: { l: 't', t: 'r', r: 'b', b: 'l' },
				};

				static DEFAULTS = { 1: null, 2: 'h', 3: 'l' };

				static ROTATIONS = {
					2: (f) => [f[1], f[0]],
					3: {
						left: (f) => [f[2], f[0], f[1]],
						right: (f) => [f[1], f[2], f[0]],
					},
				};

				constructor(apiUrl) {
					this.apiUrl = apiUrl;
					this.app = document.getElementById('app');
					this.panels = Array.from(this.app.children);
					this.state = {
						layout: 1,
						orientation: 'l',
						focus: 0,
						frames: [0, 0, 0],
						totalFrames: null,
					};
					this.cache = new Map();

					// Cache dimensions and configs
					this.dimensions = { w: 0, h: 0 };
					this.layoutCache = null;

					document.addEventListener('keydown', (e) =>
						this.handleKey(e)
					);
					window.addEventListener('resize', () => this.onResize());

					this.updateLayout();
					this.render();
				}

				handleKey(e) {
					const actions = {
						1: () => this.setLayout(1),
						2: () => this.setLayout(2),
						3: () => this.setLayout(3),
						4: () => this.cycleContent(),
						Tab: () => (e.preventDefault(), this.cycleFocus()),
						e: () => this.navigate(1),
						q: () => this.navigate(-1),
					};
					actions[e.key]?.();
				}

				setLayout(layout) {
					const { layout: current, focus } = this.state;

					if (current === layout) {
						this.toggleOrientation();
						return;
					}

					if (layout === 1 && focus) {
						[
							this.state.frames[0],
							this.state.frames[focus],
							this.state.focus,
						] = [this.state.frames[focus], this.state.frames[0], 0];
					}

					this.state.layout = layout;
					this.state.orientation = FrameViewer.DEFAULTS[layout];
					this.layoutCache = null; // Invalidate cache
					this.updateLayout();
					this.render();
				}

				toggleOrientation() {
					const { layout, orientation } = this.state;
					const cycle = FrameViewer.ORIENTATIONS[layout];
					if (cycle) {
						this.state.orientation = cycle[orientation];
						this.layoutCache = null; // Invalidate cache
						this.updateLayout();
					}
				}

				cycleFocus() {
					const { layout, focus } = this.state;
					if (layout > 1) this.state.focus = (focus + 1) % layout;
				}

				cycleContent() {
					const { layout, frames, orientation } = this.state;
					if (layout === 1) return;

					const rotations = FrameViewer.ROTATIONS;
					if (layout === 2) {
						this.state.frames = rotations[2](frames);
					} else {
						const dir =
							orientation === 'l' || orientation === 't'
								? 'left'
								: 'right';
						this.state.frames = rotations[3][dir](frames);
					}

					this.state.focus = (this.state.focus + 1) % layout;
					this.render();
				}

				navigate(delta) {
					const { focus, frames, totalFrames } = this.state;
					const max = totalFrames || 1000;
					frames[focus] =
						(((frames[focus] + delta) % max) + max) % max;
					this.renderPanel(focus);
				}

				onResize() {
					const w = this.app.clientWidth;
					const h = this.app.clientHeight;

					// Only recalculate if dimensions actually changed
					if (this.dimensions.w !== w || this.dimensions.h !== h) {
						this.dimensions = { w, h };
						this.layoutCache = null;
						this.updateLayout();
					}
				}

				updateLayout() {
					const { layout, orientation } = this.state;

					// Return cached config if available
					if (this.layoutCache) {
						this.applyLayout(this.layoutCache);
						return;
					}

					const { w, h } = this.dimensions.w
						? this.dimensions
						: (this.dimensions = {
								w: this.app.clientWidth,
								h: this.app.clientHeight,
						  });

					const config = this.getConfigs(w, h, layout, orientation);
					this.layoutCache = config;
					this.applyLayout(config);
				}

				applyLayout(config) {
					const borderStyle = '3px solid var(--border-color)';

					this.panels.forEach((p, i) => {
						if (i >= config.length) {
							p.style.display = 'none';
							return;
						}

						const { left, top, width, height, border } = config[i];
						const s = p.style;
						s.display = 'flex';
						s.left = `${left}px`;
						s.top = `${top}px`;
						s.width = `${width}px`;
						s.height = `${height}px`;
						s.border = 'none';
						if (border) s[`border${border}`] = borderStyle;
					});
				}

				getConfigs(w, h, layout, orientation) {
					const p = (l, t, w, h, b = null) => ({
						left: l,
						top: t,
						width: w,
						height: h,
						border: b,
					});
					const hw = w * 0.5;
					const hh = h * 0.5;

					const configs = {
						1: [p(0, 0, w, h)],
						2: {
							h: [p(0, 0, hw, h, 'Right'), p(hw, 0, hw, h)],
							v: [p(0, 0, w, hh, 'Bottom'), p(0, hh, w, hh)],
						},
						3: {
							l: [
								p(0, 0, hw, h, 'Right'),
								p(hw, 0, hw, hh, 'Bottom'),
								p(hw, hh, hw, hh),
							],
							t: [
								p(0, 0, w, hh, 'Bottom'),
								p(0, hh, hw, hh, 'Right'),
								p(hw, hh, hw, hh),
							],
							r: [
								p(hw, 0, hw, h, 'Left'),
								p(0, 0, hw, hh, 'Bottom'),
								p(0, hh, hw, hh),
							],
							b: [
								p(0, hh, w, hh, 'Top'),
								p(0, 0, hw, hh, 'Right'),
								p(hw, 0, hw, hh),
							],
						},
					};

					return layout === 1
						? configs[1]
						: configs[layout][orientation];
				}

				async fetchFrame(idx) {
					if (this.cache.has(idx)) return this.cache.get(idx);

					if (!this.apiUrl) {
						const html = '<div>No API URL configured</div>';
						this.cache.set(idx, html);
						return html;
					}

					try {
						const res = await fetch(this.apiUrl, {
							headers: { 'X-Frame': idx.toString() },
						});
						if (!res.ok) throw new Error(`HTTP ${res.status}`);

						const total = res.headers.get('X-Index');
						if (total && !this.state.totalFrames)
							this.state.totalFrames = parseInt(total);

						const html = await res.text();
						this.cache.set(idx, html);
						return html;
					} catch (err) {
						console.error(`Failed to fetch frame ${idx}:`, err);
						const html = `<div>Error loading frame ${idx}</div>`;
						this.cache.set(idx, html);
						return html;
					}
				}

				async renderPanel(idx) {
					this.panels[idx].innerHTML = await this.fetchFrame(
						this.state.frames[idx]
					);
				}

				async render() {
					await Promise.all(
						Array.from({ length: this.state.layout }, (_, i) =>
							this.renderPanel(i)
						)
					);
				}
			}
		</script>
	</head>
	<body>
		<div id="app">
			<div class="panel"></div>
			<div class="panel"></div>
			<div class="panel"></div>
		</div>
	</body>
</html>
