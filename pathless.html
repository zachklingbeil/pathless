<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border-width: medium;
				--border-color: blue;
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				scrollbar-width: none;
				-ms-overflow-style: none;
				user-select: none;
			}

			*::-webkit-scrollbar {
				display: none;
			}

			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
			}

			body {
				border: var(--border-width) solid var(--border-color);
				border-radius: 5px;
			}

			#app {
				height: 100vh;
				position: relative;
			}

			.panel {
				position: absolute;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 2rem;
				padding: 1em;
				overflow: auto;
				background: black;
			}

			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div id="app">
			<div class="panel"></div>
			<div class="panel"></div>
			<div class="panel"></div>
		</div>

		<script>
			class FrameViewer {
				constructor(apiUrl = '{{.APIURL}}') {
					this.apiUrl = apiUrl;
					this.app = document.getElementById('app');
					this.panels = Array.from(this.app.children);

					// State
					this.state = {
						layout: 1,
						orientation: 'h',
						focus: 0,
						frames: [0, 0, 0],
						totalFrames: null,
					};

					this.cache = new Map();
					this.borderWidth = 3;

					this.handleKey = this.handleKey.bind(this);
					this.handleResize = this.handleResize.bind(this);

					this.attachListeners();
					this.updateLayout();
					this.render();
				}

				attachListeners() {
					document.addEventListener('keydown', this.handleKey);
					window.addEventListener('resize', this.handleResize);
				}

				handleResize() {
					this.updateLayout();
				}

				handleKey(e) {
					const handlers = {
						1: () => this.setLayout(1),
						2: () => this.setLayout(2),
						3: () => this.setLayout(3),
						4: () => this.toggleOrientation(),
						5: () => this.cycleContent(),
						Tab: () => {
							e.preventDefault();
							this.cycleFocus();
						},
						e: () => this.navigate(1),
						q: () => this.navigate(-1),
					};

					const handler = handlers[e.key];
					if (handler) handler();
				}

				setLayout(layout) {
					if (this.state.layout === layout) return;

					// Moving to single panel - bring focused frame to front
					if (layout === 1 && this.state.focus !== 0) {
						this.swapFrames(0, this.state.focus);
						this.state.focus = 0;
					}

					this.state.layout = layout;
					this.updateLayout();
					this.render();
				}

				toggleOrientation() {
					if (this.state.layout === 1) return;
					this.state.orientation =
						this.state.orientation === 'h' ? 'v' : 'h';
					this.updateLayout();
				}

				cycleFocus() {
					if (this.state.layout > 1) {
						this.state.focus =
							(this.state.focus + 1) % this.state.layout;
					}
				}

				cycleContent() {
					const { layout, frames } = this.state;

					if (layout === 2) {
						this.swapFrames(0, 1);
					} else if (layout === 3) {
						const temp = frames[2];
						frames[2] = frames[1];
						frames[1] = frames[0];
						frames[0] = temp;
					}

					if (layout > 1) {
						this.state.focus = (this.state.focus + 1) % layout;
						this.render();
					}
				}

				navigate(delta) {
					const max = this.state.totalFrames || 1000;
					const idx = this.state.focus;
					this.state.frames[idx] = this.wrap(
						this.state.frames[idx] + delta,
						max
					);
					this.renderPanel(idx);
				}

				swapFrames(i, j) {
					const temp = this.state.frames[i];
					this.state.frames[i] = this.state.frames[j];
					this.state.frames[j] = temp;
				}

				wrap(val, max) {
					return ((val % max) + max) % max;
				}

				updateLayout() {
					const { layout, orientation } = this.state;
					const w = this.app.clientWidth;
					const h = this.app.clientHeight;
					const b = this.borderWidth;

					// Single panel
					if (layout === 1) {
						this.panels[0].style.cssText = `display:flex;left:0;top:0;width:${w}px;height:${h}px;border:none;`;
						this.panels[1].style.display = 'none';
						this.panels[2].style.display = 'none';
						return;
					}

					// Two panels
					if (layout === 2) {
						if (orientation === 'h') {
							const half = w / 2;
							this.panels[0].style.cssText = `display:flex;left:0;top:0;width:${half}px;height:${h}px;border-right:${b}px solid var(--border-color);border-bottom:none;`;
							this.panels[1].style.cssText = `display:flex;left:${half}px;top:0;width:${half}px;height:${h}px;border:none;`;
						} else {
							const half = h / 2;
							this.panels[0].style.cssText = `display:flex;left:0;top:0;width:${w}px;height:${half}px;border-bottom:${b}px solid var(--border-color);border-right:none;`;
							this.panels[1].style.cssText = `display:flex;left:0;top:${half}px;width:${w}px;height:${half}px;border:none;`;
						}
						this.panels[2].style.display = 'none';
						return;
					}

					// Three panels
					if (layout === 3) {
						if (orientation === 'h') {
							const halfW = w / 2;
							const halfH = h / 2;
							this.panels[0].style.cssText = `display:flex;left:0;top:0;width:${halfW}px;height:${h}px;border-right:${b}px solid var(--border-color);border-bottom:none;`;
							this.panels[1].style.cssText = `display:flex;left:${halfW}px;top:0;width:${halfW}px;height:${halfH}px;border-bottom:${b}px solid var(--border-color);border-right:none;`;
							this.panels[2].style.cssText = `display:flex;left:${halfW}px;top:${halfH}px;width:${halfW}px;height:${halfH}px;border:none;`;
						} else {
							const halfW = w / 2;
							const halfH = h / 2;
							this.panels[0].style.cssText = `display:flex;left:0;top:0;width:${w}px;height:${halfH}px;border-bottom:${b}px solid var(--border-color);border-right:none;`;
							this.panels[1].style.cssText = `display:flex;left:0;top:${halfH}px;width:${halfW}px;height:${halfH}px;border-right:${b}px solid var(--border-color);border-bottom:none;`;
							this.panels[2].style.cssText = `display:flex;left:${halfW}px;top:${halfH}px;width:${halfW}px;height:${halfH}px;border:none;`;
						}
					}
				}

				async fetchFrame(idx) {
					if (this.cache.has(idx)) return this.cache.get(idx);

					// Demo mode - no API
					if (!this.apiUrl) {
						const content = `<div>Frame ${idx}</div>`;
						this.cache.set(idx, content);
						return content;
					}

					try {
						const res = await fetch(this.apiUrl, {
							headers: { 'X-Frame-Request': idx.toString() },
						});

						if (!res.ok) throw new Error(`HTTP ${res.status}`);

						// Extract total frames from header
						const total = res.headers.get('X-Total-Frames');
						if (total && !this.state.totalFrames) {
							this.state.totalFrames = parseInt(total);
						}

						const html = await res.text();
						this.cache.set(idx, html);
						return html;
					} catch (err) {
						console.error(`Failed to fetch frame ${idx}:`, err);
						const content = `<div>Error loading frame ${idx}</div>`;
						this.cache.set(idx, content);
						return content;
					}
				}

				async renderPanel(idx) {
					const content = await this.fetchFrame(
						this.state.frames[idx]
					);
					this.panels[idx].innerHTML = content;
				}

				async render() {
					const promises = [];
					for (let i = 0; i < this.state.layout; i++) {
						promises.push(this.renderPanel(i));
					}
					await Promise.all(promises);
				}
			}

			// Initialize app
			const viewer = new FrameViewer('');
		</script>
	</body>
</html>
