<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			*,
			*::before,
			*::after {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				scrollbar-width: none;
				-ms-overflow-style: none;
				user-select: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			a,
			a:hover,
			a:visited,
			a:active,
			a:focus {
				text-align: center;
				color: inherit;
				text-decoration: underline;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				scroll-behavior: smooth;
			}

			body {
				font-family: 'Roboto', sans-serif;
				background: black;
				border: var(--border);
				border-radius: 0.3125em;
				color: white;
			}

			#container {
				height: 100vh;
				display: grid;
			}

			.section {
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 2rem;
				contain: layout paint;
				overflow: auto;
				padding: 1em;
			}

			/* Grid layouts */
			.layout-single {
				grid-template: 1fr / 1fr;
			}
			.layout-halves {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-halves.vertical {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-split {
				grid-template: 1fr 1fr / 1fr 1fr;
			}

			/* Hidden sections */
			.layout-single #s2,
			.layout-single #s3,
			.layout-halves #s3 {
				display: none;
			}

			/* Borders */
			.layout-halves #s1,
			.layout-split #s1 {
				border-right: var(--border);
			}

			.layout-halves.vertical #s1,
			.layout-split #s2,
			.layout-split.vertical #s1 {
				border-bottom: var(--border);
			}

			/* Grid positions */
			.layout-split #s1 {
				grid-row: 1 / 3;
			}

			.layout-split.vertical #s1 {
				grid-row: 1;
				grid-column: 1 / 3;
			}

			/* Vertical overrides */
			.layout-halves.vertical #s1,
			.layout-split.vertical #s1 {
				border-right: none;
			}

			.layout-split.vertical #s2 {
				border-bottom: none;
				border-right: var(--border);
			}
		</style>
	</head>
	<body>
		<div id="container" class="layout-single">
			<div id="s1" class="section"></div>
			<div id="s2" class="section"></div>
			<div id="s3" class="section"></div>
		</div>

		<script>
			const API_URL = '{{.APIURL}}';
			const container = document.getElementById('container');
			const sectionElements = Array.from(container.children);

			// Layout configuration
			const LAYOUTS = {
				'layout-single': { key: '1', count: 1 },
				'layout-halves': { key: '2', count: 2 },
				'layout-split': { key: '3', count: 3 },
			};

			// State
			const sections = [{ frame: 0 }, { frame: 0 }, { frame: 0 }];
			let currentLayout = 'layout-single';
			let orientation = 'horizontal';
			let focusedSection = 0;
			let totalFrames = null;

			// Cache
			const cache = new Map();

			// Utilities
			const wrap = (val, max) => ((val % max) + max) % max;

			const swapFrames = (i, j) => {
				[sections[i].frame, sections[j].frame] = [
					sections[j].frame,
					sections[i].frame,
				];
			};

			const getVisibleCount = () => LAYOUTS[currentLayout].count;

			// Fetch frame content
			const fetchFrame = async (idx) => {
				if (!API_URL) {
					cache.set(idx, `<div>Frame ${idx}</div>`);
					return;
				}

				if (cache.has(idx)) return;

				try {
					const res = await fetch(API_URL, {
						headers: { 'X-Frame-Request': idx.toString() },
					});

					if (!res.ok) throw new Error(`HTTP ${res.status}`);

					const total = res.headers.get('X-Total-Frames');
					if (total && !totalFrames) {
						totalFrames = parseInt(total);
					}

					const html = await res.text();
					cache.set(idx, html);
				} catch (err) {
					console.error(`Failed to fetch frame ${idx}:`, err);
					cache.set(idx, `<div>Error loading frame ${idx}</div>`);
				}
			};

			// Render a single section
			const renderSection = (i) => {
				const content = cache.get(sections[i].frame);
				if (content) {
					sectionElements[i].innerHTML = content;
				}
			};

			// Update display: fetch and render all visible sections
			const updateDisplay = async () => {
				const count = getVisibleCount();

				// Fetch all needed frames
				const fetches = [];
				for (let i = 0; i < count; i++) {
					fetches.push(fetchFrame(sections[i].frame));
				}
				await Promise.all(fetches);

				// Render all visible sections
				for (let i = 0; i < count; i++) {
					renderSection(i);
				}
			};

			// Apply layout classes to container
			const applyLayout = () => {
				const classes = [currentLayout];
				if (
					orientation === 'vertical' &&
					currentLayout !== 'layout-single'
				) {
					classes.push('vertical');
				}
				container.className = classes.join(' ');
			};

			// Set layout mode
			const setLayout = (layoutName) => {
				if (currentLayout === layoutName) return;

				// When going to single layout, swap focused section to position 0
				if (layoutName === 'layout-single' && focusedSection !== 0) {
					swapFrames(0, focusedSection);
					focusedSection = 0;
				}

				currentLayout = layoutName;
				applyLayout();
				updateDisplay();
			};

			// Toggle between horizontal and vertical orientation
			const toggleOrientation = () => {
				if (currentLayout === 'layout-single') return;

				orientation =
					orientation === 'horizontal' ? 'vertical' : 'horizontal';
				applyLayout();
			};

			// Cycle focus between visible sections
			const cycleFocus = () => {
				const count = getVisibleCount();
				if (count > 1) {
					focusedSection = (focusedSection + 1) % count;
				}
			};

			// Cycle content between sections
			const cycleContent = () => {
				const count = getVisibleCount();

				if (count === 2) {
					swapFrames(0, 1);
				} else if (count === 3) {
					const temp = sections[2].frame;
					sections[2].frame = sections[1].frame;
					sections[1].frame = sections[0].frame;
					sections[0].frame = temp;
				}

				if (count > 1) {
					focusedSection = (focusedSection + 1) % count;
					updateDisplay();
				}
			};

			// Navigate forward or backward
			const navigate = (direction) => {
				const max = totalFrames || 1000;
				sections[focusedSection].frame = wrap(
					sections[focusedSection].frame + direction,
					max
				);
				fetchFrame(sections[focusedSection].frame).then(() =>
					renderSection(focusedSection)
				);
			};

			// Keyboard command map
			const COMMANDS = {
				1: () => setLayout('layout-single'),
				2: () => setLayout('layout-halves'),
				3: () => setLayout('layout-split'),
				4: toggleOrientation,
				5: cycleContent,
				Tab: (e) => {
					e.preventDefault();
					cycleFocus();
				},
				e: () => navigate(1),
				q: () => navigate(-1),
			};

			// Keyboard controls
			document.addEventListener('keydown', (e) => {
				const command = COMMANDS[e.key];
				if (command) {
					command(e);
				}
			});

			// Initialize
			updateDisplay();
		</script>
	</body>
</html>
