<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
				-ms-overflow-style: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
				scroll-behavior: smooth;
			}
			body {
				border: var(--border);
				border-radius: 0.3125em;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
			img {
				max-width: 100%;
				max-height: 90%;
				width: auto;
				height: auto;
				display: block;
				object-fit: contain;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.panel {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.panel > * {
				max-width: 100%;
				object-fit: contain;
			}
			/* Single panel */
			.layout-0-0 {
				grid-template: 1fr / 1fr;
			}
			/* Two panels - horizontal */
			.layout-1-0 {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-1-0 #zero {
				border-right: var(--border);
			}
			/* Two panels - vertical */
			.layout-1-1 {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-1-1 #zero {
				border-bottom: var(--border);
			}
			/* Three panels - all variants */
			.layout-2-0,
			.layout-2-1,
			.layout-2-2,
			.layout-2-3 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			/* Variant 0: Left large (zero), right stacked */
			.layout-2-0 #zero {
				grid-row: 1 / 3;
				border-right: var(--border);
			}
			.layout-2-0 #one {
				border-bottom: var(--border);
			}
			/* Variant 1: Top large (zero), bottom split */
			.layout-2-1 #zero {
				grid-column: 1 / 3;
				border-bottom: var(--border);
			}
			.layout-2-1 #one {
				border-right: var(--border);
			}
			/* Variant 2: Right large (zero), left stacked */
			.layout-2-2 #zero {
				grid-row: 1 / 3;
				grid-column: 2;
				border-left: var(--border);
			}
			.layout-2-2 #one {
				border-bottom: var(--border);
			}
			/* Variant 3: Bottom large (zero), top split */
			.layout-2-3 #zero {
				grid-row: 2;
				grid-column: 1 / 3;
				border-top: var(--border);
			}
			.layout-2-3 #one {
				border-right: var(--border);
			}
		</style>
		<script>
			window.apiUrl = '{{.APIURL}}';

			class App {
				constructor() {
					this.layoutManager = new LayoutManager();
					this.frameSource = new FrameSource();
					this.panelFrames = new Map(
						this.layoutManager.panels.map((panel) => [panel, 0])
					);

					document.addEventListener('keydown', (e) =>
						this.handleKey(e)
					);
					this.renderAll();
				}

				async renderAll() {
					await Promise.all(
						this.layoutManager.getVisiblePanels().map((panel) => {
							const frameIndex = this.panelFrames.get(panel);
							return this.frameSource.render(panel, frameIndex);
						})
					);
				}

				async navigate(delta) {
					const total = this.frameSource.totalFrames || 1;
					const panel = this.layoutManager.getFocusedPanel();
					const currentFrame = this.panelFrames.get(panel);
					const newFrame =
						(((currentFrame + delta) % total) + total) % total;

					this.panelFrames.set(panel, newFrame);
					await this.frameSource.render(panel, newFrame);
				}

				handleKey(e) {
					const keyMap = {
						e: () => this.navigate(1),
						q: () => this.navigate(-1),
						1: () => this.layoutManager.toggleFullscreen(),
						2: () => {
							this.layoutManager.changeLayout(1);
							this.renderAll();
						},
						3: () => {
							this.layoutManager.changeLayout(2);
							this.renderAll();
						},
						Tab: () => this.layoutManager.cycleFocus(),
						r: () => this.resetAllPanels(),
					};

					const handler = keyMap[e.key];
					if (handler) {
						e.preventDefault();
						handler();
					}

					this.layoutManager
						.getFocusedPanel()
						?.dispatchEvent(
							new CustomEvent('panelKey', { detail: e })
						);
				}

				resetAllPanels() {
					this.layoutManager.panels.forEach((panel) => {
						this.panelFrames.set(panel, 0);
						this.frameSource.clearPanelState(panel);
					});
					this.renderAll();
				}
			}

			class FrameSource {
				constructor() {
					this.frames = new Map();
					this.totalFrames = null;
					this.pending = new Map();
				}

				async fetchFrame(idx) {
					if (this.frames.has(idx)) return this.frames.get(idx);
					if (this.pending.has(idx)) return this.pending.get(idx);

					if (this.totalFrames === null && idx !== 0)
						await this.fetchFrame(0);

					if (!window.apiUrl) {
						const error = '<div>No API URL configured</div>';
						this.frames.set(idx, error);
						return error;
					}

					const fetchPromise = this._fetch(idx);
					this.pending.set(idx, fetchPromise);

					try {
						const content = await fetchPromise;
						this.frames.set(idx, content);
						return content;
					} finally {
						this.pending.delete(idx);
					}
				}

				async _fetch(idx) {
					try {
						const res = await fetch(window.apiUrl, {
							headers:
								idx === 0 ? {} : { 'X-Frame': String(idx) },
						});

						if (!res.ok) throw new Error(`HTTP ${res.status}`);

						if (this.totalFrames === null) {
							const total = res.headers.get('X-Frames');
							if (total) this.totalFrames = parseInt(total, 10);
						}

						return await res.text();
					} catch (err) {
						console.error(`Failed to fetch frame ${idx}:`, err);
						return `<div>Error loading frame ${idx}</div>`;
					}
				}

				async fetchData(key, url) {
					const dataKey = `__data_${key}`;

					// Return cached data if already fetched (shared across all panels)
					if (this.frames.has(dataKey))
						return this.frames.get(dataKey);

					// Return pending promise if currently fetching (prevents duplicate requests)
					if (this.pending.has(dataKey))
						return this.pending.get(dataKey);

					// Fetch and cache globally
					const promise = fetch(url)
						.then(async (res) => {
							if (!res.ok)
								return Promise.reject(`HTTP ${res.status}`);

							const contentType = res.headers.get('content-type');

							// Handle images - return blob URL
							if (contentType?.startsWith('image/')) {
								const blob = await res.blob();
								return URL.createObjectURL(blob);
							}

							// Handle JSON
							return res.json();
						})
						.then((data) => {
							this.frames.set(dataKey, data); // Cache globally for all panels
							return data;
						})
						.catch((err) => {
							console.error(`Error fetching data ${key}:`, err);
							throw err;
						});

					this.pending.set(dataKey, promise);

					try {
						return await promise;
					} finally {
						this.pending.delete(dataKey);
					}
				}

				getData(key) {
					return this.frames.get(`__data_${key}`);
				}

				async render(panel, frameIdx) {
					const content = await this.fetchFrame(frameIdx);
					panel.innerHTML = content;

					if (!panel.__frameState) panel.__frameState = {};

					['script', 'style'].forEach((tag) => {
						panel.querySelectorAll(tag).forEach((old) => {
							const el = document.createElement(tag);
							Array.from(old.attributes).forEach((attr) =>
								el.setAttribute(attr.name, attr.value)
							);
							el.textContent = old.textContent;
							old.replaceWith(el);
						});
					});

					panel.dispatchEvent(
						new CustomEvent('frameRendered', {
							detail: { frameIdx },
						})
					);
				}

				waitForImages(element) {
					const images = Array.from(element.querySelectorAll('img'));
					return Promise.all(
						images.map((img) =>
							img.complete
								? Promise.resolve()
								: new Promise((resolve) => {
										img.addEventListener('load', resolve);
										img.addEventListener('error', resolve);
								  })
						)
					);
				}

				getPanelState(panel) {
					return panel.__frameState || {};
				}

				setPanelState(panel, key, value) {
					if (!panel.__frameState) panel.__frameState = {};
					panel.__frameState[key] = value;
				}

				clearPanelState(panel) {
					panel.__frameState = {};
				}
			}

			class LayoutManager {
				constructor() {
					this.app = document.getElementById('app');
					this.panels = ['zero', 'one', 'two'].map((id) =>
						document.getElementById(id)
					);
					this.layout = [0, 0];
					this.focus = 0;
					this.isFullscreen = false;
					this.savedState = null;
					this.layouts = [
						{ panels: 1, variants: 1 },
						{ panels: 2, variants: 2 },
						{ panels: 3, variants: 4 },
					];
					this.render();
				}

				getVisibleCount() {
					return this.layouts[this.layout[0]].panels;
				}

				getVisiblePanels() {
					return this.panels.slice(0, this.getVisibleCount());
				}

				getFocusedPanel() {
					return this.panels[this.focus];
				}

				getPanelByElement(element) {
					return element.closest('.panel');
				}

				getPanelIndex(panel) {
					return this.panels.indexOf(panel);
				}

				cycleFocus() {
					if (this.isFullscreen) return;
					this.focus = (this.focus + 1) % this.getVisibleCount();
					this._renderFocus();
				}

				changeLayout(targetLayout) {
					if (this.isFullscreen) {
						this.toggleFullscreen();
					}
					this.setLayout(targetLayout);
				}

				toggleFullscreen() {
					if (this.isFullscreen) {
						this._exitFullscreen();
					} else {
						this._enterFullscreen();
					}
				}

				_enterFullscreen() {
					this.savedState = {
						layout: [...this.layout],
						focus: this.focus,
					};
					this.isFullscreen = true;
					this.layout = [0, 0];
					this.render();

					// Show only focused panel
					this.panels.forEach((panel, i) => {
						panel.style.display =
							i === this.savedState.focus ? 'flex' : 'none';
					});
				}

				_exitFullscreen() {
					this.isFullscreen = false;
					this.layout = this.savedState.layout;
					this.focus = this.savedState.focus;
					this.savedState = null;
					this.render();
				}

				setLayout(layoutIndex) {
					const currentLayout = this.layouts[layoutIndex];
					const layoutChanged = this.layout[0] !== layoutIndex;

					if (layoutChanged) {
						// Reset focus if it's out of bounds for new layout
						if (this.focus >= currentLayout.panels) {
							this.focus = 0;
						}
						this.layout = [layoutIndex, 0];
					} else {
						// Cycle through variants
						this.layout[1] =
							(this.layout[1] + 1) % currentLayout.variants;
					}

					this.render();
				}

				render() {
					this._renderLayout();
					this._renderFocus();
				}

				_renderLayout() {
					const visibleCount = this.getVisibleCount();
					this.app.className = `layout-${this.layout[0]}-${this.layout[1]}`;

					this.panels.forEach((panel, i) => {
						panel.style.display =
							i < visibleCount ? 'flex' : 'none';
					});
				}

				_renderFocus() {
					this.panels.forEach((panel, i) => {
						panel.classList.toggle('focused', i === this.focus);
					});
				}
			}

			document.addEventListener('DOMContentLoaded', () => {
				window.app = new App();
				window.frameAPI = {
					getPanel: (scriptElement) =>
						window.app.layoutManager.getPanelByElement(
							scriptElement
						),
					getFrameIndex: (panel) => {
						return window.app.panelFrames.get(panel) || 0;
					},
					getState: (panel) =>
						window.app.frameSource.getPanelState(panel),
					setState: (panel, key, value) =>
						window.app.frameSource.setPanelState(panel, key, value),
					waitForImages: (element) =>
						window.app.frameSource.waitForImages(element),
					fetchData: (key, url) =>
						window.app.frameSource.fetchData(key, url),
					getData: (key) => window.app.frameSource.getData(key),
					onKey: (panel, handler) => {
						panel.addEventListener('panelKey', (e) =>
							handler(e.detail.key)
						);
					},
				};
			});
		</script>
	</head>
	<body>
		<div id="app">
			<div id="zero" class="panel"></div>
			<div id="one" class="panel"></div>
			<div id="two" class="panel"></div>
		</div>
	</body>
</html>
