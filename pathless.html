<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
				-ms-overflow-style: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
				scroll-behavior: smooth;
			}
			body {
				border: var(--border);
				border-radius: 0.3125em;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.panel {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.panel > * {
				width: 100%;
				height: 100%;
			}
			/* Single panel */
			.layout-0-0 {
				grid-template: 1fr / 1fr;
			}
			/* Two panels - horizontal */
			.layout-1-0 {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-1-0 #zero {
				border-right: var(--border);
			}
			/* Two panels - vertical */
			.layout-1-1 {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-1-1 #zero {
				border-bottom: var(--border);
			}
			/* Three panels - all variants */
			.layout-2-0,
			.layout-2-1,
			.layout-2-2,
			.layout-2-3 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			/* Variant 0: Left large (zero), right stacked */
			.layout-2-0 #zero {
				grid-row: 1 / 3;
				border-right: var(--border);
			}
			.layout-2-0 #one {
				border-bottom: var(--border);
			}
			/* Variant 1: Top large (zero), bottom split */
			.layout-2-1 #zero {
				grid-column: 1 / 3;
				border-bottom: var(--border);
			}
			.layout-2-1 #one {
				border-right: var(--border);
			}
			/* Variant 2: Right large (zero), left stacked */
			.layout-2-2 #zero {
				grid-row: 1 / 3;
				grid-column: 2;
				border-left: var(--border);
			}
			.layout-2-2 #one {
				border-bottom: var(--border);
			}
			/* Variant 3: Bottom large (zero), top split */
			.layout-2-3 #zero {
				grid-row: 2;
				grid-column: 1 / 3;
				border-top: var(--border);
			}
			.layout-2-3 #one {
				border-right: var(--border);
			}
		</style>
		<script>
			class One {
				constructor() {
					window.apiUrl = '{{.APIURL}}';
					this.fx = new Fx();
					document.addEventListener('keydown', (e) =>
						this.handleKey(e)
					);
					this.fx.render();
				}

				async handleKey(e) {
					const actions = {
						e: () => this.fx.navigate(1),
						q: () => this.fx.navigate(-1),
						1: () => this.fx.toggleFullscreen(),
						2: () => this.fx.setLayout(1),
						3: () => this.fx.setLayout(2),
						Tab: () => {
							e.preventDefault();
							this.fx.cycleFocus();
						},
					};

					const action = actions[e.key];
					if (action) {
						await action();
					} else {
						this.fx.handleKey(e.key);
					}
				}
			}

			class Fx {
				constructor() {
					this.zero = new Zero();
					this.app = document.getElementById('app');
					this.panels = ['zero', 'one', 'two'].map((id) => ({
						element: document.getElementById(id),
						frameIndex: 0,
					}));
					this.state = {
						layoutIndex: 0,
						variantIndex: 0,
						focusedPanel: 0,
						previousLayout: null,
					};
					this.handlers = new Map();
					this.layouts = [
						{ panels: 1, variants: 1 },
						{ panels: 2, variants: 2 },
						{ panels: 3, variants: 4 },
					];
				}

				context() {
					const layout = this.layouts[this.state.layoutIndex];
					const visible = this.panels.slice(0, layout.panels);
					const focused = this.panels[this.state.focusedPanel];

					if (!focused.element.__state) focused.element.__state = {};

					return {
						layout,
						visible,
						focused,
						panel: focused.element,
						frameIndex: focused.frameIndex,
						state: focused.element.__state,
						visibleCount: visible.length,
					};
				}

				update(key, value) {
					this.context().state[key] = value;
				}

				handleKey(key, handler) {
					const { panel, frameIndex } = this.context();
					const handlerKey = `${panel.id}-${frameIndex}`;

					if (handler !== undefined) {
						this.handlers.set(handlerKey, handler);
					} else {
						const registeredHandler = this.handlers.get(handlerKey);
						if (registeredHandler) registeredHandler(key);
					}
				}

				async toggleFullscreen() {
					if (
						this.state.layoutIndex === 0 &&
						this.state.previousLayout
					) {
						// Restore from fullscreen
						this.state.layoutIndex =
							this.state.previousLayout.layoutIndex;
						this.state.variantIndex =
							this.state.previousLayout.variantIndex;
						this.state.focusedPanel =
							this.state.previousLayout.focusedPanel;
						this.state.previousLayout = null;
					} else if (this.state.layoutIndex !== 0) {
						// Go to fullscreen
						this.state.previousLayout = {
							layoutIndex: this.state.layoutIndex,
							variantIndex: this.state.variantIndex,
							focusedPanel: this.state.focusedPanel,
						};
						this.state.layoutIndex = 0;
						this.state.variantIndex = 0;
						// focusedPanel stays the same
					}

					await this.render();
				}

				async setLayout(index) {
					const newLayout = this.layouts[index];

					// Clear previous layout when explicitly changing
					this.state.previousLayout = null;

					if (this.state.focusedPanel >= newLayout.panels) {
						this.state.focusedPanel = 0;
					}

					if (this.state.layoutIndex === index) {
						this.state.variantIndex =
							(this.state.variantIndex + 1) % newLayout.variants;
					} else {
						this.state.layoutIndex = index;
						this.state.variantIndex = 0;
					}

					await this.render();
				}

				cycleFocus() {
					const { visibleCount } = this.context();
					this.state.focusedPanel =
						(this.state.focusedPanel + 1) % visibleCount;
					this.updateDisplay();
				}

				async navigate(delta) {
					const { focused } = this.context();
					const total = this.zero.totalFrames || 1;
					const next = (focused.frameIndex + delta + total) % total;

					focused.frameIndex = next;
					await this.zero.renderPanel(focused.element, next);
				}

				updateDisplay() {
					const { visible } = this.context();
					this.app.className = `layout-${this.state.layoutIndex}-${this.state.variantIndex}`;
					this.panels.forEach((p, i) => {
						if (this.state.layoutIndex === 0) {
							// In fullscreen, only show the focused panel
							p.element.style.display =
								i === this.state.focusedPanel ? 'flex' : 'none';
						} else {
							// In multi-panel layouts, show visible panels
							p.element.style.display =
								i < visible.length ? 'flex' : 'none';
						}
					});
				}

				async render() {
					const { visible } = this.context();
					await Promise.all(
						visible.map((p) =>
							this.zero.renderPanel(p.element, p.frameIndex)
						)
					);
					this.updateDisplay();
				}
			}

			class Zero {
				constructor() {
					this.cache = new Map();
					this.pending = new Map();
					this.totalFrames = null;
					this.frameUrl = `${window.apiUrl}/frame`;
				}

				async fetch(key, url, options = {}) {
					if (this.cache.has(key)) {
						const cached = this.cache.get(key);
						return cached; // Return both data and headers
					}
					if (this.pending.has(key)) return this.pending.get(key);

					const promise = fetch(url, options)
						.then(async (res) => {
							if (!res.ok) throw new Error(`HTTP ${res.status}`);

							const type = res.headers.get('content-type');
							const data = type?.startsWith('image/')
								? URL.createObjectURL(await res.blob())
								: type?.includes('json')
								? await res.json()
								: await res.text();

							const result = { data, headers: res.headers };
							this.cache.set(key, result); // Cache both data and headers
							return result;
						})
						.catch((err) => {
							console.error(`Fetch failed for "${key}":`, err);
							throw err;
						})
						.finally(() => this.pending.delete(key));

					this.pending.set(key, promise);
					return promise;
				}

				async fetchFrame(idx) {
					if (this.totalFrames === null) {
						const { data, headers } = await this.fetch(
							0,
							this.frameUrl,
							{}
						);
						const total = headers.get('X-Frames');
						if (total) this.totalFrames = parseInt(total, 10);
						return data;
					}

					try {
						const { data } = await this.fetch(idx, this.frameUrl, {
							headers: { 'X-Frame': String(idx) },
						});
						return data;
					} catch (err) {
						return `<div>Error loading frame ${idx}</div>`;
					}
				}

				async renderPanel(panelElement, frameIndex) {
					const html = await this.fetchFrame(frameIndex);

					panelElement.innerHTML = html;

					if (!panelElement.__state) panelElement.__state = {};

					['script', 'style'].forEach((tag) => {
						panelElement.querySelectorAll(tag).forEach((old) => {
							const el = document.createElement(tag);
							Array.from(old.attributes).forEach((attr) =>
								el.setAttribute(attr.name, attr.value)
							);
							el.textContent = old.textContent;
							old.replaceWith(el);
						});
					});
				}
			}

			document.addEventListener('DOMContentLoaded', () => {
				window.one = new One();
				window.frameAPI = {
					context: () => window.one.fx.context(),
					update: (k, v) => window.one.fx.update(k, v),
					fetch: (k, u) => window.one.fx.zero.fetch(k, u),
					onKey: (h) => window.one.fx.handleKey(null, h),
				};
			});
		</script>
	</head>
	<body>
		<div id="app">
			<div id="zero" class="panel"></div>
			<div id="one" class="panel"></div>
			<div id="two" class="panel"></div>
		</div>
	</body>
</html>
