<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
				-ms-overflow-style: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
				scroll-behavior: smooth;
			}
			body {
				border: var(--border);
				border-radius: 0.3125em;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
			img {
				max-width: 100%;
				max-height: 90%;
				width: auto;
				height: auto;
				display: block;
				object-fit: contain;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.panel {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.panel > * {
				max-width: 100%;
				object-fit: contain;
			}
			/* Single panel */
			.layout-0-0 {
				grid-template: 1fr / 1fr;
			}
			/* Two panels - horizontal */
			.layout-1-0 {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-1-0 #zero {
				border-right: var(--border);
			}
			/* Two panels - vertical */
			.layout-1-1 {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-1-1 #zero {
				border-bottom: var(--border);
			}
			/* Three panels - all variants */
			.layout-2-0,
			.layout-2-1,
			.layout-2-2,
			.layout-2-3 {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			/* Variant 0: Left large (zero), right stacked */
			.layout-2-0 #zero {
				grid-row: 1 / 3;
				border-right: var(--border);
			}
			.layout-2-0 #one {
				border-bottom: var(--border);
			}
			/* Variant 1: Top large (zero), bottom split */
			.layout-2-1 #zero {
				grid-column: 1 / 3;
				border-bottom: var(--border);
			}
			.layout-2-1 #one {
				border-right: var(--border);
			}
			/* Variant 2: Right large (zero), left stacked */
			.layout-2-2 #zero {
				grid-row: 1 / 3;
				grid-column: 2;
				border-left: var(--border);
			}
			.layout-2-2 #one {
				border-bottom: var(--border);
			}
			/* Variant 3: Bottom large (zero), top split */
			.layout-2-3 #zero {
				grid-row: 2;
				grid-column: 1 / 3;
				border-top: var(--border);
			}
			.layout-2-3 #one {
				border-right: var(--border);
			}
		</style>
		<script>
			class App {
				constructor(apiUrl) {
					this.app = document.getElementById('app');
					this.panels = [
						document.getElementById('zero'),
						document.getElementById('one'),
						document.getElementById('two'),
					];
					window.apiUrl = apiUrl;
					this.frames = new Map();
					this.frameSource = new FrameSource(apiUrl, this.frames);
					this.layoutManager = new LayoutManager(
						this.app,
						this.panels
					);
					this.panelFrames = [0, 0, 0];

					document.addEventListener('keydown', (e) =>
						this.handleKey(e)
					);
					this.renderAll();
				}

				async renderAll() {
					const visibleCount =
						this.layoutManager.layouts[this.layoutManager.layout[0]]
							.panels;
					const visiblePanels = this.panels.slice(0, visibleCount);
					const visibleFrames = this.panelFrames.slice(
						0,
						visibleCount
					);
					await this.frameSource.renderFrames(
						visiblePanels,
						visibleFrames
					);
				}

				async navigate(delta) {
					const focusedIdx = this.layoutManager.focus;
					const currentFrame = this.panelFrames[focusedIdx];
					const newFrame = this.frameSource.getNextFrame(
						currentFrame,
						delta
					);

					this.panelFrames[focusedIdx] = newFrame;
					await this.frameSource.renderFrame(
						this.panels[focusedIdx],
						newFrame
					);
				}

				changeLayout(targetLayout) {
					if (this.layoutManager.isFullscreen) {
						this.layoutManager.toggleFullscreen();
					}
					this.layoutManager.setLayout(targetLayout);
				}
				handleKey(e) {
					const keyMap = {
						e: () => this.navigate(1),
						q: () => this.navigate(-1),
						1: () => this.layoutManager.toggleFullscreen(),
						2: () => this.changeLayout(1),
						3: () => this.changeLayout(2),
						Tab: () => this.layoutManager.cycleFocus(),
					};
					const handler = keyMap[e.key];
					if (handler) {
						e.preventDefault();
						handler();
					}
					this.panels[this.layoutManager.focus]?.dispatchEvent(
						new CustomEvent('panelKey', { detail: e })
					);
				}
			}

			class FrameSource {
				constructor(apiUrl, framesCache) {
					this.apiUrl = apiUrl;
					this.framesCache = framesCache;
					this.totalFrames = null;
					this.pending = new Map();
				}

				getNextFrame(currentFrame, delta) {
					const total = this.totalFrames || 1;
					return (((currentFrame + delta) % total) + total) % total;
				}

				async fetchFrame(idx) {
					if (this.framesCache.has(idx)) {
						return this.framesCache.get(idx);
					}

					if (this.pending.has(idx)) {
						return this.pending.get(idx);
					}

					if (this.totalFrames === null && idx !== 0) {
						await this.fetchFrame(0);
					}

					if (!this.apiUrl) {
						const error = '<div>No API URL configured</div>';
						this.framesCache.set(idx, error);
						return error;
					}

					const fetchPromise = this._performFetch(idx);
					this.pending.set(idx, fetchPromise);

					try {
						const content = await fetchPromise;
						this.framesCache.set(idx, content);
						return content;
					} finally {
						this.pending.delete(idx);
					}
				}

				async _performFetch(idx) {
					try {
						const res =
							idx === 0
								? await fetch(this.apiUrl)
								: await fetch(this.apiUrl, {
										headers: { 'X-Frame': String(idx) },
								  });

						if (!res.ok) {
							throw new Error(`HTTP ${res.status}`);
						}

						if (this.totalFrames === null) {
							const total = res.headers.get('X-Total-Frames');
							if (total) {
								this.totalFrames = parseInt(total, 10);
							}
						}

						return await res.text();
					} catch (err) {
						console.error(`Failed to fetch frame ${idx}:`, err);
						return `<div>Error loading frame ${idx}</div>`;
					}
				}

				async renderFrame(panelElement, frameIdx) {
					const content = await this.fetchFrame(frameIdx);
					panelElement.innerHTML = content;
				}

				async renderFrames(panelElements, frameIndices) {
					await Promise.all(
						panelElements.map((panel, i) =>
							this.renderFrame(panel, frameIndices[i])
						)
					);
				}
			}

			class LayoutManager {
				constructor(app, panels) {
					this.app = app;
					this.panels = panels;
					this.layout = [0, 0];
					this.focus = 0;
					this.isFullscreen = false;
					this.savedLayout = null;
					this.savedFocusedIdx = null;
					this.layouts = [
						{ panels: 1, variants: 1 },
						{ panels: 2, variants: 2 },
						{ panels: 3, variants: 4 },
					];
					this.render();
				}

				cycleFocus() {
					this.focus =
						(this.focus + 1) % this.layouts[this.layout[0]].panels;
					this.renderFocus();
				}

				toggleFullscreen() {
					if (this.isFullscreen) {
						this.isFullscreen = false;
						this.layout = this.savedLayout;
						this.render();
					} else {
						this.savedLayout = [...this.layout];
						this.savedFocusedIdx = this.focus;
						this.isFullscreen = true;
						this.layout = [0, 0];
						this.render();
						this.panels.forEach((panel, i) => {
							if (i !== this.savedFocusedIdx) {
								panel.style.display = 'none';
							}
						});
					}
				}

				setLayout(layoutIndex) {
					const layoutChanged = this.layout[0] !== layoutIndex;
					const currentLayout = this.layouts[layoutIndex];

					if (layoutChanged) {
						if (this.focus >= currentLayout.panels) {
							this.focus = 0;
						}
						this.layout = [layoutIndex, 0];
					} else {
						this.layout[1] =
							(this.layout[1] + 1) % currentLayout.variants;
					}

					this.render();
				}

				render() {
					this.renderLayout();
					this.renderFocus();
				}

				renderLayout() {
					const currentLayout = this.layouts[this.layout[0]];
					this.app.className = `layout-${this.layout[0]}-${this.layout[1]}`;

					this.panels.forEach((panel, i) => {
						panel.style.display =
							i < currentLayout.panels ? 'flex' : 'none';
					});
				}

				renderFocus() {
					this.panels.forEach((panel, i) => {
						panel.classList.toggle('focused', i === this.focus);
					});
				}
			}
			document.addEventListener('DOMContentLoaded', () => {
				new App('{{.APIURL}}');
			});
		</script>
	</head>
	<body>
		<div id="app">
			<div id="zero" class="panel"></div>
			<div id="one" class="panel"></div>
			<div id="two" class="panel"></div>
		</div>
	</body>
</html>
