<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			*,
			*::before,
			*::after {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				scrollbar-width: none;
				-ms-overflow-style: none;
				user-select: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			a,
			a:hover,
			a:visited,
			a:active,
			a:focus {
				text-align: center;
				color: inherit;
				text-decoration: underline;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				scroll-behavior: smooth;
			}

			body {
				font-family: 'Roboto', sans-serif;
				background: black;
				border: var(--border);
				border-radius: 0.3125em;
				color: white;
			}

			#container {
				height: 100vh;
				display: grid;
			}

			.section {
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 2rem;
				contain: layout paint;
				overflow: auto;
				padding: 1em;
			}

			/* Grid layouts */
			.layout-single {
				grid-template: 1fr / 1fr;
			}
			.layout-halves {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-halves.vertical {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-split {
				grid-template: 1fr 1fr / 1fr 1fr;
			}

			/* Hidden sections */
			.layout-single #s2,
			.layout-single #s3,
			.layout-halves #s3 {
				display: none;
			}

			/* Borders */
			.layout-halves #s1,
			.layout-split #s1 {
				border-right: var(--border);
			}

			.layout-halves.vertical #s1,
			.layout-split #s2,
			.layout-split.vertical #s1 {
				border-bottom: var(--border);
			}

			/* Grid positions */
			.layout-split #s1 {
				grid-row: 1 / 3;
			}

			.layout-split.vertical #s1 {
				grid-row: 1;
				grid-column: 1 / 3;
			}

			/* Vertical overrides */
			.layout-halves.vertical #s1,
			.layout-split.vertical #s1 {
				border-right: none;
			}

			.layout-split.vertical #s2 {
				border-bottom: none;
				border-right: var(--border);
			}
		</style>
	</head>
	<body>
		<div id="container" class="layout-single">
			<div id="s1" class="section"></div>
			<div id="s2" class="section"></div>
			<div id="s3" class="section"></div>
		</div>

		<script>
			const API_URL = '{{.APIURL}}';
			const container = document.getElementById('container');
			const sections = Array.from(container.children);

			let states = [0, null, null];
			let focusedIndex = 0;
			let totalFrames = null;
			let currentLayout = 'layout-single';

			const cache = new Map();
			const pending = new Map();

			const layouts = {
				1: 'layout-single',
				2: 'layout-halves',
				3: 'layout-split',
			};

			const layoutCounts = {
				'layout-single': 1,
				'layout-halves': 2,
				'layout-split': 3,
			};

			const fetchFrame = async (idx) => {
				if (!API_URL) {
					cache.set(idx, `<div>Frame ${idx}</div>`);
					return;
				}

				if (cache.has(idx) || pending.has(idx)) {
					return pending.get(idx);
				}

				const promise = fetch(API_URL, {
					headers: { 'X-Frame-Request': idx.toString() },
				})
					.then((res) => {
						if (!res.ok) throw new Error(`HTTP ${res.status}`);

						const total = res.headers.get('X-Total-Frames');
						if (total && !totalFrames)
							totalFrames = parseInt(total);

						return res.text();
					})
					.then((html) => {
						cache.set(idx, html);
						pending.delete(idx);
					})
					.catch((err) => {
						console.error(`Failed to fetch frame ${idx}:`, err);
						cache.set(idx, `<div>Error loading frame ${idx}</div>`);
						pending.delete(idx);
					});

				pending.set(idx, promise);
				return promise;
			};

			const renderSection = (i) => {
				const content = cache.get(states[i]);
				if (content) sections[i].innerHTML = content;
			};

			const updateDisplay = async () => {
				const count = layoutCounts[currentLayout];
				const promises = [];

				// Initialize unset states
				for (let i = 0; i < count; i++) {
					if (states[i] === null) {
						states[i] = i === 2 ? 0 : states[0];
					}
				}

				for (let i = 0; i < count; i++) {
					const promise = fetchFrame(states[i]);
					if (promise) promises.push(promise);
				}

				await Promise.all(promises);

				for (let i = 0; i < count; i++) {
					renderSection(i);
				}
			};

			const setLayout = (layout) => {
				if (
					currentLayout === layout &&
					!container.classList.contains('vertical')
				)
					return;

				const wasVertical = container.classList.contains('vertical');

				if (
					layout === 'layout-single' &&
					currentLayout !== 'layout-single' &&
					focusedIndex !== 0
				) {
					[states[0], states[focusedIndex]] = [
						states[focusedIndex],
						states[0],
					];
					focusedIndex = 0;
				} else if (
					layout !== 'layout-single' &&
					currentLayout === 'layout-single'
				) {
					focusedIndex = 0;
				}

				currentLayout = layout;
				container.className =
					layout +
					(wasVertical && layout !== 'layout-single'
						? ' vertical'
						: '');
				updateDisplay();
			};

			const toggleOrientation = () => {
				if (currentLayout !== 'layout-single') {
					container.classList.toggle('vertical');
				}
			};

			const cycleFocus = () => {
				const count = layoutCounts[currentLayout];
				if (count > 1) focusedIndex = (focusedIndex + 1) % count;
			};

			const cycleContent = () => {
				if (currentLayout === 'layout-halves') {
					[states[0], states[1]] = [states[1], states[0]];
					focusedIndex ^= 1;
					updateDisplay();
				} else if (currentLayout === 'layout-split') {
					const temp = states[2];
					states[2] = states[1];
					states[1] = states[0];
					states[0] = temp;
					focusedIndex = (focusedIndex + 1) % 3;
					updateDisplay();
				}
			};

			const navigate = (direction) => {
				const max = totalFrames || 1000;
				const current = states[focusedIndex];
				let next = current + direction;

				// Wrap around
				if (next < 0) next = max - 1;
				if (next >= max) next = 0;

				if (next !== current) {
					states[focusedIndex] = next;
					fetchFrame(next).then(() => renderSection(focusedIndex));
				}
			};

			document.addEventListener('keydown', (e) => {
				const layout = layouts[e.key];
				if (layout) {
					setLayout(layout);
				} else if (e.key === '4') {
					toggleOrientation();
				} else if (e.key === 'Tab') {
					e.preventDefault();
					cycleFocus();
				} else if (e.key === '5') {
					cycleContent();
				} else if (e.key.toLowerCase() === 'e') {
					navigate(1);
				} else if (e.key.toLowerCase() === 'q') {
					navigate(-1);
				}
			});

			updateDisplay();
		</script>
	</body>
</html>
