<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>{{.Title}}</title>
		<style>
			:root {
				--border: medium solid blue;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				user-select: none;
				scrollbar-width: none;
				-ms-overflow-style: none;
			}
			*::-webkit-scrollbar {
				display: none;
			}
			html,
			body {
				height: 100vh;
				overflow: hidden;
				font-family: 'Roboto', sans-serif;
				background: black;
				color: white;
				scroll-behavior: smooth;
			}
			body {
				border: var(--border);
				border-radius: 0.3125em;
			}
			a {
				color: inherit;
				text-decoration: underline;
				text-align: center;
			}
			img {
				max-width: 100%;
				max-height: 90%;
				width: auto;
				height: auto;
				display: block;
				object-fit: contain;
			}
			#app {
				height: 100vh;
				display: grid;
			}
			.panel {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 1em;
				overflow: hidden;
			}
			.panel > * {
				max-width: 100%;
				object-fit: contain;
			}
			.layout-0 {
				grid-template: 1fr / 1fr;
			}
			.layout-1-h {
				grid-template: 1fr / 1fr 1fr;
			}
			.layout-1-v {
				grid-template: 1fr 1fr / 1fr;
			}
			.layout-2-l,
			.layout-2-t,
			.layout-2-r,
			.layout-2-b {
				grid-template: 1fr 1fr / 1fr 1fr;
			}
			.layout-1-h .panel:first-child {
				border-right: var(--border);
			}
			.layout-1-v .panel:first-child {
				border-bottom: var(--border);
			}
			.layout-2-l .panel:first-child {
				grid-row: 1 / 3;
				border-right: var(--border);
			}
			.layout-2-r .panel:nth-child(1) {
				grid-column: 1;
				grid-row: 1;
			}
			.layout-2-r .panel:nth-child(2) {
				grid-column: 1;
				grid-row: 2;
				border-top: var(--border);
			}
			.layout-2-r .panel:nth-child(3) {
				grid-row: 1 / 3;
				grid-column: 2;
				border-left: var(--border);
			}
			.layout-2-t .panel:first-child {
				grid-column: 1 / 3;
				border-bottom: var(--border);
			}
			.layout-2-b .panel:last-child {
				grid-column: 1 / 3;
				border-top: var(--border);
			}
			.layout-2-l .panel:nth-child(2),
			.layout-2-t .panel:nth-child(2) {
				border-bottom: var(--border);
			}
			.layout-2-t .panel:nth-child(2),
			.layout-2-b .panel:nth-child(1) {
				border-right: var(--border);
			}
		</style>
		<script>
			const LAYOUT_CONFIG = [
				{ default: null, orientations: null, rotate: null },
				{
					default: 'h',
					orientations: { h: 'v', v: 'h' },
					rotate: (f) => [f[1], f[0]],
				},
				{
					default: 'l',
					orientations: { l: 't', t: 'r', r: 'b', b: 'l' },
					rotate: {
						left: (f) => [f[2], f[0], f[1]],
						right: (f) => [f[1], f[2], f[0]],
					},
				},
			];
			document.addEventListener(
				'DOMContentLoaded',
				() => new FrameViewer('{{.APIURL}}')
			);
			class FrameViewer {
				constructor(apiUrl) {
					this.apiUrl = apiUrl;
					this.app = document.getElementById('app');
					this.panels = Array.from(this.app.children);
					this.totalFrames = null;
					this.state = {
						layout: 0,
						orientation: 'l',
						focus: 0,
						frames: [0, 0, 0],
					};
					this.cache = new Map();

					document.addEventListener('keydown', (e) => {
						this.handleKey(e);
						const panel = this.panels[this.state.focus];
						if (panel)
							panel.dispatchEvent(
								new CustomEvent('panelKey', { detail: e })
							);
					});
					this.updateLayout();
					this.render();
				}
				handleKey(e) {
					const actions = {
						1: () => this.setLayout(0),
						2: () => this.setLayout(1),
						3: () => this.setLayout(2),
						4: () => this.cycleContent(),
						Tab: () => (e.preventDefault(), this.cycleFocus()),
						e: () => this.navigate(1),
						q: () => this.navigate(-1),
					};
					actions[e.key]?.();
				}
				setLayout(layout) {
					const { layout: currentLayout, focus, frames } = this.state;
					if (currentLayout === layout) {
						this.toggleOrientation();
						return;
					}
					if (focus >= layout + 1) {
						[frames[0], frames[focus]] = [frames[focus], frames[0]];
						this.state.focus = 0;
					}
					this.state.layout = layout;
					this.state.orientation = LAYOUT_CONFIG[layout].default;
					this.updateLayout();
					this.render();
				}
				toggleOrientation() {
					const { layout, orientation } = this.state;
					const config = LAYOUT_CONFIG[layout];
					if (!config.orientations) return;
					this.state.orientation = config.orientations[orientation];
					this.updateLayout();
				}
				cycleFocus() {
					const { layout, focus } = this.state;
					if (layout > 0)
						this.state.focus = (focus + 1) % (layout + 1);
				}
				cycleContent() {
					const { layout, frames, orientation } = this.state;
					if (layout === 0) return;
					const config = LAYOUT_CONFIG[layout];
					if (layout === 1) {
						this.state.frames = config.rotate(frames);
					} else {
						const dir =
							orientation === 'l' || orientation === 't'
								? 'left'
								: 'right';
						this.state.frames = config.rotate[dir](frames);
					}
					this.state.focus = (this.state.focus + 1) % (layout + 1);
					this.render();
				}
				navigate(delta) {
					const { focus, frames } = this.state;
					const max = this.totalFrames ?? 1000;
					frames[focus] = (frames[focus] + delta + max) % max;
					this.render([focus]);
				}
				updateLayout() {
					const { layout, orientation } = this.state;
					this.app.className =
						layout === 0
							? 'layout-0'
							: `layout-${layout}-${orientation}`;
					for (let i = 0; i < this.panels.length; i++) {
						const panel = this.panels[i];
						const shouldShow = i < layout + 1 ? 'flex' : 'none';
						if (panel.style.display !== shouldShow) {
							panel.style.display = shouldShow;
						}
					}
				}
				async fetchFrame(idx) {
					if (this.cache.has(idx)) return this.cache.get(idx);
					if (!this.apiUrl) {
						const html = '<div>No API URL configured</div>';
						this.cache.set(idx, html);
						return html;
					}
					try {
						const res = await fetch(this.apiUrl, {
							headers: { 'X-Frame': idx.toString() },
						});
						if (!res.ok) throw new Error(`HTTP ${res.status}`);
						const total = res.headers.get('X-Index');
						if (total && !this.totalFrames)
							this.totalFrames = parseInt(total);
						const html = await res.text();
						this.cache.set(idx, html);
						return html;
					} catch (err) {
						console.error(`Failed to fetch frame ${idx}:`, err);
						const html = `<div>Error loading frame ${idx}</div>`;
						this.cache.set(idx, html);
						return html;
					}
				}
				async render(indices) {
					const panelsToRender = indices ?? [
						...Array(this.state.layout + 1).keys(),
					];
					await Promise.all(
						panelsToRender.map(async (i) => {
							const panel = this.panels[i];
							panel.innerHTML = await this.fetchFrame(
								this.state.frames[i]
							);
							const scripts = panel.querySelectorAll('script');
							scripts.forEach((s) => {
								try {
									new Function('panel', s.textContent)(panel);
								} catch (e) {
									console.error(e);
								}
							});
						})
					);
				}
			}
		</script>
	</head>
	<body>
		<div id="app">
			<div class="panel"></div>
			<div class="panel"></div>
			<div class="panel"></div>
		</div>
	</body>
</html>
